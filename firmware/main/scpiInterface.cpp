#include "scpiInterface.h"
#include "scpiInterfaceCommandTree.h"
#include "config.h"

// For the error buffer
#include "LIFObuf.h"

// For the update of the FPGA parameters
#include "fpga.h"

static void Identify(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void Reset(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void SerialErrorHandler(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void GetLastError(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void GetErrorSize(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void SCPIversion(SCPI_C commands, SCPI_P parameters, Stream& interface);

static void dacSetVoltage(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void dacGetVoltage(SCPI_C commands, SCPI_P parameters, Stream& interface);

static void serialSetStream(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void serialGetStream(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void serialSetRaw(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void serialGetRaw(SCPI_C commands, SCPI_P parameters, Stream& interface);

static void accurateSetCharge(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateGetCharge(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateSetCooldown(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateGetCooldown(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateSetReset(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateGetReset(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateSetTCharge(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateGetTCharge(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateSetTInjection(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateGetTInjection(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateSetDisableCP(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateGetDisableCP(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateSetSingly(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void accurateGetSingly(SCPI_C commands, SCPI_P parameters, Stream& interface);

static void printHelp(SCPI_C commands, SCPI_P parameters, Stream& interface);
static void DoNothing(SCPI_C commands, SCPI_P parameters, Stream& interface);

void addErrorToBuffer(String error);
bool checkNumberParameters(SCPI_P parameters, uint8_t number);

/**
 * @brief After the function is executed, all the parameters are updated in the FPGA
 * @param func The function to be executed before updating the FPGA parameters
 */
#define PARAM_UPDATE(func) [](SCPI_C commands, SCPI_P parameters, Stream& interface) { \
    func(commands, parameters, interface); \
    fpgaUpdateAllParam(); \
    }


/**
 * @brief Error buffer, implemented as LIFO buffer
 * 
 * All the errors generated by the SCPI parser AND the commands are stored in
 * this buffer. If the error queue overflows, the last error is replaced with a 
 * "Queue Overflow" error.
*/
static LIFObuf<String> errorBuffer(ERROR_BUFFER_SIZE);

void init_scpiInterface() {
    /*
    To fix hash crashes, the hashing magic numbers can be changed before 
    registering commands.
    Use prime numbers up to the SCPI_HASH_TYPE size.
    */
    my_instrument.hash_magic_number = 37; //Default value = 37
    my_instrument.hash_magic_offset = 7;  //Default value = 7

    my_instrument.timeout = 10; //value in miliseconds. Default value = 10


    my_instrument.SetCommandTreeBase(F("STATus:OPERation"));
        my_instrument.RegisterCommand(F(":CONDition?"), &DoNothing);
        my_instrument.RegisterCommand(F(":ENABle"), &DoNothing);
        my_instrument.RegisterCommand(F(":EVENt?"), &DoNothing);
    my_instrument.SetCommandTreeBase(F("STATus:QUEStionable"));
        my_instrument.RegisterCommand(F(":CONDition?"), &DoNothing);
        my_instrument.RegisterCommand(F(":ENABle"), &DoNothing);
        my_instrument.RegisterCommand(F(":EVENt?"), &DoNothing);
    my_instrument.SetCommandTreeBase(F("STATus"));
        my_instrument.RegisterCommand(F(":OPERation?"), &DoNothing);
        my_instrument.RegisterCommand(F(":QUEStionable?"), &DoNothing);
        my_instrument.RegisterCommand(F(":PRESet"), &DoNothing);
    my_instrument.SetCommandTreeBase(F(""));
    my_instrument.RegisterCommand(F("*CLS"), &DoNothing);
    my_instrument.RegisterCommand(F("*ESE"), &DoNothing);
    my_instrument.RegisterCommand(F("*ESE?"), &DoNothing);
    my_instrument.RegisterCommand(F("*ESR"), &DoNothing);
    my_instrument.RegisterCommand(F("*OPC"), &DoNothing);
    my_instrument.RegisterCommand(F("*OPC?"), &DoNothing);
    my_instrument.RegisterCommand(F("*SRE"), &DoNothing);
    my_instrument.RegisterCommand(F("*SRE?"), &DoNothing);
    my_instrument.RegisterCommand(F("*STB"), &DoNothing);
    my_instrument.RegisterCommand(F("*TST?"), &DoNothing);
    my_instrument.RegisterCommand(F("*WAI"), &DoNothing);
    
    // ---------------- Implemented commands ----------------
    my_instrument.SetCommandTreeBase(F("SYSTem"));
        my_instrument.RegisterCommand(F(":ERRor?"), &GetLastError);
        my_instrument.RegisterCommand(F(":ERRor:NEXT?"), &GetLastError);
        my_instrument.RegisterCommand(F(":ERRor:COUNt?"), &GetErrorSize);
        my_instrument.RegisterCommand(F(":VERSion?"), &SCPIversion);
    my_instrument.SetCommandTreeBase(F("CONFigure:DAC"));
        my_instrument.RegisterCommand(F(":VOLTage#"), PARAM_UPDATE(dacSetVoltage));
        my_instrument.RegisterCommand(F(":VOLTage?"), &dacGetVoltage);
    my_instrument.SetCommandTreeBase(F("CONFigure:ACCUrate"));
        my_instrument.RegisterCommand(F(":CHARGE#"), PARAM_UPDATE(accurateSetCharge));
        my_instrument.RegisterCommand(F(":CHARGE?#"), &accurateGetCharge);
        my_instrument.RegisterCommand(F(":COOLdown#"), PARAM_UPDATE(accurateSetCooldown));
        my_instrument.RegisterCommand(F(":COOLdown?#"), &accurateGetCooldown);
        my_instrument.RegisterCommand(F(":RESET#"), PARAM_UPDATE(accurateSetReset));
        my_instrument.RegisterCommand(F(":RESET?"), &accurateGetReset);
        my_instrument.RegisterCommand(F(":TCHARGE#"), PARAM_UPDATE(accurateSetTCharge));
        my_instrument.RegisterCommand(F(":TCHARGE?"), &accurateGetTCharge);
        my_instrument.RegisterCommand(F(":TINJection#"), PARAM_UPDATE(accurateSetTInjection));
        my_instrument.RegisterCommand(F(":TINJection?"), &accurateGetTInjection);
        my_instrument.RegisterCommand(F(":DISABLE#"), PARAM_UPDATE(accurateSetDisableCP));
        my_instrument.RegisterCommand(F(":DISABLE?#"), &accurateGetDisableCP);
        my_instrument.RegisterCommand(F(":SINGLY#"), PARAM_UPDATE(accurateSetSingly));
        my_instrument.RegisterCommand(F(":SINGLY?"), &accurateGetSingly);
    my_instrument.SetCommandTreeBase(F("CONFigure:SERIal"));
        my_instrument.RegisterCommand(F(":STREAM#"), &serialSetStream);
        my_instrument.RegisterCommand(F(":STREAM?"), &serialGetStream);
        my_instrument.RegisterCommand(F(":RAW#"), &serialSetRaw);
        my_instrument.RegisterCommand(F(":RAW?"), &serialGetRaw);
    my_instrument.SetCommandTreeBase(F(""));
    my_instrument.RegisterCommand(F("*IDN?"), &Identify);
    my_instrument.RegisterCommand(F("*RST"), &Reset);
    my_instrument.RegisterCommand(F("HELP?"), &printHelp);


    // my_instrument.PrintDebugInfo(Serial);
    my_instrument.SetErrorHandler(&SerialErrorHandler);
}


// -------------------------------------------------------------------
// ---------------- Functions of implemented commands ----------------
// -------------------------------------------------------------------

static void Identify(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 0) == false) return;

    String outMessage = "CERN, REV1, ";
    for (uint8_t i = 0; i < 4; i++) {
        outMessage += String(( *(conf.UUID+i) ), HEX);
    }
    outMessage += ", 1.4.0";
    interface.println(outMessage);
}

static void Reset(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    delay(1000);
    /*
    CMSIS (Cortex Microcontroller Software Interface Standard) function
    Set the SYSRESETREQ in the NVIC (Nested Vectored Interrupt Controller),
    causing the MCU to reset.
    */
    NVIC_SystemReset();
}

static void GetLastError(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 0) == false) return;

    if (errorBuffer.empty()) {
        interface.println("0, No Error");
    } else {
        interface.println(errorBuffer.pop());
    }
}

static void GetErrorSize(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 0) == false) return;
    interface.println(errorBuffer.size());
}

static void SCPIversion(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 0) == false) return;
    interface.println("NOT SCPI COMPLIANT");
}

static void dacSetVoltage(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 2) == false) return;

    uint8_t channel = toupper(parameters.First()[0]) - 'A';
    float voltage = atof(parameters.Last());

    conf.dac[channel] = voltage;
}

static void dacGetVoltage(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 1) == false) return;

    uint8_t channel = toupper(parameters.First()[0]) - 'A';
    interface.println(conf.dac[channel]);
}

static void serialSetStream(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 1) == false) return;

    String first_parameter = String(parameters.First());
    first_parameter.toUpperCase();

    if (first_parameter == "ON") {
        conf.serial.stream = true;
    } else if (first_parameter == "OFF") {
        conf.serial.stream = false;
    } else {
        interface.println("Invalid parameter");
    }
}

static void serialGetStream(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 0) == false) return;
    interface.println(conf.serial.stream);
}

static void serialSetRaw(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 1) == false) return;

    String first_parameter = String(parameters.First());
    first_parameter.toUpperCase();

    if (first_parameter == "ON") {
        conf.serial.rawOutput = true;
    } else if (first_parameter == "OFF") {
        conf.serial.rawOutput = false;
    } else {
        interface.println("Invalid parameter");
    }
}

static void serialGetRaw(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 0) == false) return;
    interface.println(conf.serial.rawOutput);
}

static void printHelp(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 0) == false) return;
    interface.println(scpiCommandTree);
}

static void accurateSetCharge(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 2) == false) return;

    uint8_t channel = atoi(parameters.First());
    if (channel < 1 || channel > 3) {
        interface.println("Invalid channel number");
        return;
    }

    float charge = atoi(parameters.Last());
    conf.acc.chargeQuantaCP[channel - 1] = charge;
}

static void accurateGetCharge(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 1) == false) return;

    uint8_t channel = atoi(parameters.First());
    if (channel < 1 || channel > 3) {
        interface.println("Invalid channel number");
        return;
    }

    interface.println(conf.acc.chargeQuantaCP[channel - 1]);
}

static void accurateSetCooldown(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 3) == false) return;

    String type = String(parameters.First());
    type.toUpperCase();

    uint8_t channel = atoi(parameters[1]); // pick the second element
    if (channel < 1 || channel > 3) {
        interface.println("Invalid channel number");
        return;
    }

    uint32_t time = atoi(parameters.Last());

    if (type == "MIN") {
        conf.acc.cooldownMinCP[channel - 1] = time;
    } else if (type == "MAX") {
        conf.acc.cooldownMaxCP[channel - 1] = time;
    } else {
        interface.println("Invalid type parameter");
    }
}

static void accurateGetCooldown(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 2) == false) return;

    String type = String(parameters.First());
    type.toUpperCase();

    uint8_t channel = atoi(parameters.Last());
    if (channel < 1 || channel > 3) {
        interface.println("Invalid channel number");
        return;
    }

    if (type == "MIN") {
        interface.println(conf.acc.cooldownMinCP[channel - 1]);
    } else if (type == "MAX") {
        interface.println(conf.acc.cooldownMaxCP[channel - 1]);
    } else {
        interface.println("Invalid type parameter");
    }
}

static void accurateSetReset(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 1) == false) return;

    uint8_t reset = atoi(parameters.First());
    if (reset != 0 && reset != 1) {
        interface.println("Invalid parameter");
        return;
    }

    conf.acc.resetOTA = reset;
}

static void accurateGetReset(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 0) == false) return;

    interface.println(conf.acc.resetOTA);
}

static void accurateSetTCharge(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 1) == false) return;

    uint8_t time = atoi(parameters.First());
    if (time <= 0) {
        time = 1;
    }

    conf.acc.tCharge = time;
}

static void accurateGetTCharge(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 0) == false) return;

    interface.println(conf.acc.tCharge);
}

static void accurateSetTInjection(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 1) == false) return;

    uint8_t time = atoi(parameters.First());
    if (time <= 0) {
        time = 1;
    }

    conf.acc.tInjection = time;
}

static void accurateGetTInjection(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 0) == false) return;

    interface.println(conf.acc.tInjection);
}

static void accurateSetDisableCP(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 2) == false) return;

    uint8_t channel = atoi(parameters.First());
    if (channel < 1 || channel > 3) {
        interface.println("Invalid channel number");
        return;
    }

    uint8_t disable = atoi(parameters.Last());
    if (disable != 0 && disable != 1) {
        interface.println("Invalid parameter");
        return;
    }

    conf.acc.disableCP[channel - 1] = disable;
}

static void accurateGetDisableCP(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 1) == false) return;

    uint8_t channel = atoi(parameters.First());
    if (channel < 1 || channel > 3) {
        interface.println("Invalid channel number");
        return;
    }

    interface.println(conf.acc.disableCP[channel - 1]);
}

static void accurateSetSingly(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 1) == false) return;

    uint8_t activate = atoi(parameters.First());
    if (activate != 0 && activate != 1) {
        interface.println("Invalid parameter");
        return;
    }

    conf.acc.singlyCPActivation = activate;
}

static void accurateGetSingly(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    if (checkNumberParameters(parameters, 0) == false) return;

    interface.println(conf.acc.singlyCPActivation);
}

static void DoNothing(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    addErrorToBuffer("Command not implemented");
}


// ------------------------------------------------------------
// ------------------- UTILITY FUNCTIONS ----------------------
// ------------------------------------------------------------

/**
 * @brief Add an error to the error buffer 
 * @param error Error message to add to the buffer
 * 
 * The function check if the buffer is full, if so it replace the last error
 * with a "Queue Overflow" error.
*/
void addErrorToBuffer(String error) {
    if (errorBuffer.full()) {
        errorBuffer.pop();
        errorBuffer.push("Queue Overflow");
    } else {
        errorBuffer.push(error);
    }
}

/**
 * @brief Check if the number of parameters is correct
 * @param parameters The parameters object
 * @param number The number of expected parameters
 * 
 * This function checks if the number of parameters is correct. If the number
 * is wrong, it adds the corresponding error to the error buffer.
 * 
 * @return True if the number of parameters is correct, false otherwise
 */
bool checkNumberParameters(SCPI_P parameters, uint8_t number) {
    if (parameters.Size() > number) {
        addErrorToBuffer("-108, Parameter not allowed");
        return false;
    } else if (parameters.Size() < number) {
        addErrorToBuffer("-109, Missing parameter");
        return false;
    }
    return true;
}

/**
 * @brief Serial error handler
 * 
 * This function is called every time an error occurs on the parser side.
 * It checks the error code and adds the corresponding error message to the
 * error buffer.
 */
static void SerialErrorHandler(SCPI_C commands, SCPI_P parameters, Stream& interface) {
    // This function is called every time an error occurs on the parser side
    switch(my_instrument.last_error){
        case my_instrument.ErrorCode::BufferOverflow: 
            errorBuffer.push("-100, Buffer overflow error");
            break;
        case my_instrument.ErrorCode::Timeout:
            errorBuffer.push("-100, Communication timeout error");
            break;
        case my_instrument.ErrorCode::UnknownCommand:
            errorBuffer.push("-102, Unknown command received");
            break;
        case my_instrument.ErrorCode::NoError:
            break;
    }
    my_instrument.last_error = my_instrument.ErrorCode::NoError;

    /* For BufferOverflow errors, the rest of the message, still in the interface
    buffer or not yet received, will be processed later and probably 
    trigger another kind of error.
    Here we flush the incoming message*/
    if (my_instrument.last_error == SCPI_Parser::ErrorCode::BufferOverflow) {
        delay(2);
        while (interface.available()) {
        delay(2);
        interface.read();
        }
    }
}